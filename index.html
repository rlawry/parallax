<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Orbits</title>

  <style>
    body {
      overflow: hidden; /* Hide scrollbars */
      margin: 0;
      padding: 0;
    }
    canvas {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #eccentricity {
      position: absolute;
      top: 100px;
      left: 200px;
      color: white;
      font-family: sans-serif;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <script type="module">
    // Import Three.js and controls from CDN
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.124/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/controls/OrbitControls.js';

    // Aliases for convenience
    const { MeshPhongMaterial, TextureLoader, CubeTextureLoader } = THREE;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      5500
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Lights
    const color = 0xFFFFFF;
    const intensity = 2;
    const planetLight = new THREE.PointLight(color, intensity, 100, 2);
    const sunSpotlight = new THREE.PointLight(0xffffff, 2, 500);
    sunSpotlight.position.set(0, 5, 0);

    const ambLight = new THREE.AmbientLight(0x404040);
    scene.add(ambLight);

    // Materials
    const meshMaterial = new MeshPhongMaterial({ color: 0x156289, emissive: 0x072534 });
    const sunMaterial = new MeshPhongMaterial({ color: 0xcebc21, emissive: 0xd1b982 });

    const sphereGeometry = new THREE.SphereGeometry(1, 40, 20);

    const sun = new THREE.Mesh(sphereGeometry, sunMaterial);
    const sphere3 = new THREE.Mesh(sphereGeometry, meshMaterial);
    scene.add(sun);
    scene.add(sphere3);

    planetLight.position.y = 20;
    scene.add(planetLight);

    // Background sky texture
    const loader = new THREE.TextureLoader();
    loader.load('eso_dark.jpg', function (skyTexture) {
      const skyGeometry = new THREE.SphereGeometry(5000, 60, 40);
      skyGeometry.applyMatrix4(new THREE.Matrix4().makeScale(-1, 1, 1));
      const skyMaterial = new THREE.MeshBasicMaterial({ map: skyTexture });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);

      let m = new THREE.Matrix4();
      m.makeRotationY(3 * Math.PI / 2);
      m.makeRotationX(-1.099);
      sky.applyMatrix4(m);
      m = new THREE.Matrix4();
      m.makeRotationY(Math.PI / 2);
      sky.applyMatrix4(m);

      scene.add(sky);
    });

    // Planet data
    var Planet = {
      x: 0,
      y: 0,
      rx: 220,
      ry: 220,
      degreeOffset: 180,
      degrees: -180,
      gravitationalConstant: 0.00000000006673889,
      MSun: 1988500,
      GMSun: 1.32712440018,
      day: 1
    };

    var a = Planet.rx * Planet.rx;
    var b = Planet.ry * Planet.ry;
    var c = Math.sqrt(a - b);
    Planet.c = c;

    const curve = new THREE.EllipseCurve(
      c, 0,
      Planet.rx, Planet.ry,
      0, 2 * Math.PI,
      false,
      0
    );

    const points = curve.getPoints(150);
    const ellipseGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const ellipseMaterial = new THREE.LineBasicMaterial({ color: 0xff1dce });
    const ellipse = new THREE.Line(ellipseGeometry, ellipseMaterial);
    ellipse.rotation.x = Math.PI / 2;
    scene.add(ellipse);

    // Stars
    const star = [];
    const max = 2300;
    const min = -2300;
    for (let i = 0; i < 800; i++) {
      const starMaterial = new MeshPhongMaterial({ color: 'blue', emissive: 0x8e8e8e });
      const starGeometry = new THREE.SphereGeometry(Math.random() * 20, 20, 20);
      const s = new THREE.Mesh(starGeometry, starMaterial);
      s.position.x = Math.random() * (max - min) + min;
      s.position.y = Math.random() * (max - min) + min;
      s.position.z = Math.random() * (max - min) + min;
      s.material.emissive.setRGB(Math.random(), Math.random(), Math.random());
      s.material.color.setRGB(Math.random(), Math.random(), Math.random());
      scene.add(s);
      star.push(s);
    }

    // Planet orbit setup
    function initPlanet() {
      a = Planet.rx * Planet.rx;
      b = Planet.ry * Planet.ry;
      c = Math.sqrt(a - b);
      Planet.c = c;

      ellipse.position.x = c;
      ellipse.scale.x = Planet.rx / Planet.ry;

      document.getElementById("eccentricity").innerHTML = Planet.day / 2;
    }

    function calculateOrbitalSpeedPlanet() {
      var tx = (Planet.rx * Math.cos(toRadiansPlanet(Planet.degrees))) + Planet.c;
      var ty = (Planet.ry * Math.sin(toRadiansPlanet(Planet.degrees)));
      var speed = ((Math.sqrt((Planet.GMSun * 1e20) * ((2 / ((Math.sqrt((tx ** 2 + ty ** 2))) * 1e9)) - (1 / (Planet.rx * 1e9))))) / 1000) * 3600;
      return speed;
    }

    function updatePlanet() {
      Planet.orbitalSpeedActual = calculateOrbitalSpeedPlanet();
      Planet.degrees = Planet.degrees - ((360 / 365.256) * ((Planet.orbitalSpeedActual / 1000 * 0.5)));
      Planet.day++;
      if (Planet.degrees < -360 - Planet.degreeOffset) {
        Planet.degrees = 0 - Planet.degreeOffset;
        Planet.day = 1;
      }
      initPlanet();
    }

    function renderPointPlanet(x, y) {
      sphere3.position.set(x, 0, y);
    }

    function toRadiansPlanet(value) {
      return value * (Math.PI / 180);
    }

    camera.position.y = 5;
    var lookAtIndex = 2;
    camera.lookAt(star[lookAtIndex].position);
    initPlanet();

   let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();
  const delta = (now - lastTime) / 1000; // seconds since last frame
  lastTime = now;

  // update orbital position
  Planet.orbitalSpeedActual = calculateOrbitalSpeedPlanet();

  // scale orbit motion by delta and a slowdown factor
  const slowdown = 8; // smaller = slower orbit
Planet.degrees -=
  ((360 / 365.256) *
    (Planet.orbitalSpeedActual * 0.00005)) * // tweak multiplier for realism
  delta *
  slowdown;

  // wrap around degrees
  if (Planet.degrees < -360 - Planet.degreeOffset) {
    Planet.degrees = 0 - Planet.degreeOffset;
    Planet.day = 1;
  }

  // update ellipse and eccentricity readout
  initPlanet();

  // move planet
  renderPointPlanet(
    Planet.x +
      Planet.c +
      Planet.rx * Math.cos(toRadiansPlanet(Planet.degrees)),
    Planet.y + Planet.ry * Math.sin(toRadiansPlanet(Planet.degrees))
  );

  // move light with planet
  planetLight.position.copy(sphere3.position).add(new THREE.Vector3(0, 20, 0));

  // follow camera
  camera.position.x = sphere3.position.x;
  camera.position.z = sphere3.position.z;
  camera.lookAt(star[lookAtIndex].position);

  renderer.render(scene, camera);
}
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.body.onkeyup = function (e) {
      if (e.keyCode == 32) {
        lookAtIndex = (lookAtIndex + 1) % star.length;
      }
    }
  </script>

  <div id="eccentricity"></div>
</body>
</html>
